# 임베디드 리눅스의 4요소

1. **툴체인 (toolchain)**:  
   타깃 장치를 위한 코드를 만드는 데 필요한 컴파일러와 기타 도구로 구성.

2. **부트로더 (bootloader)**:  
   보드를 초기화하고 리눅스 커널을 로드하는 프로그램.

3. **커널**:  
   시스템의 심장부로, 시스템 자원을 관리하며 하드웨어와의 접점.

4. **루트 파일 시스템**:  
   커널이 초기화를 끝낸 뒤 실행되는 라이브러리와 프로그램을 담고 있음.

---

# 오픈 소스

1. **GPL 같은 Copyleft 라이선스**:  
   본질적으로 라이선스의 조건을 변경하지 않는 한 소스 코드 수정 및 사용 허용.

2. **BSD, MIT와 같은 허용적인 라이선스**:  
   소스 코드 공유.

---

# 임베디드 리눅스를 위한 하드웨어 선택하기

1. 커널이 지원하는 CPU 아키텍처.
2. 적절한 크기의 RAM 필요.
3. 비휘발성 메모리가 있음.
4. 디버그 포트는 매우 유용하며 UART 기반 시리얼 포트를 선호.
5. 아무것도 없이 시작할 때는 소프트웨어를 로드할 방법이 필요.

---

# 툴체인

소스 코드를 타깃 장치에서 실행할 수 있는 실행 파일로, 컴파일러, 링커, 런타임 라이브러리를 포함하는 컴파일 도구들의 집합.  
나머지 세 요소(부트로더, 커널, 루트 파일 시스템)을 빌드하기 위해 툴체인이 필요.  
어셈블리, C, C++ 언어로 작성된 코드를 컴파일할 수 있어야 하며, 해당 프로세서를 위한 최적의 명령어 세트를 사용하여 하드웨어를 효과적으로 사용할 수 있어야 함.  
프로젝트 내내 바뀌지 않아야 함.

### 표준 GNU 툴체인 3요소

1. **Binutils**:  
   어셈블러와 링커를 포함하는 바이너리 유틸리티의 집합.

2. **GCC**:  
   C언어와 여러 언어를 위한 컴파일러, 공통 백엔드를 사용해 어셈블러 코드를 만들고 GNU 어셈블러로 넘김.

3. **C 라이브러리**:  
   POSIX 규격에 기반을 둔 표준 API, 애플리케이션에서 운영체제 커널로 연결되는 주요 인터페이스.

이와 함께 커널에 직접 접근할 때 필요한 정의와 상수를 담고 있는 리눅스 커널 헤더가 필요.  
C 라이브러리를 컴파일하기 위해 필요하며, 특정 리눅스 장치와 상호작용하는 라이브러리를 컴파일할 때도 필요.

### 툴체인의 종류

1. **네이티브**:  
   툴체인이 만들어내는 프로그램과 같은 종류의 시스템, 때로는 실제로 같은 시스템에서 실행.

2. **크로스**:  
   툴체인이 타깃 기계와 다른 종류의 시스템에서 실행됨, 빠른 데스크톱 PC에서 개발한 다음 임베디드 디바이스로 로드해 테스트 가능.

---

# CPU 아키텍처

툴체인은 타깃 CPU의 특징에 맞게 빌드되어야 함.

1. **CPU 아키텍처**:  
   ARM, MIPS 등.

2. **빅 엔디언 또는 리틀 엔디언**:  
   어떤 CPU는 두 가지 모드로 동작할 수 있지만, 기계어 코드가 각각 다름.

3. **부동소수점 지원**:  
   모든 버전의 임베디드 프로세서가 하드웨어 부동 소수점 장치를 구현하지 않음. 이 경우 툴체인은 소프트웨어 부동소수점 라이브러리를 부르도록 설정할 수 있음.

4. **ABI**:  
   함수 호출 간에 인자를 넘기는 호출 규칙.

### GNU 접두어

1. **CPU**:  
   ARM, MIPS, x86_64 같은 아키텍처.  
   리틀 엔디언(el), 빅 엔디언(eb)를 붙여 구별 (예: mipsel, armeb).

2. **벤더**:  
   Buildroot, poky, unknown.

3. **커널**:  
   
4. **운영체제**:  
   사용자 공간 요소의 이름, gnu나 musl이 될 수 있음.

`$ gcc -dumpmachine` 옵션을 이용하면 툴체인을 빌드할 때 쓰인 조합을 알 수 있음.

예: `$ gcc -dumpmachine`  
`x86_64-linux-gnu` 

---

# C 라이브러리 고르기

유닉스 운영체제의 프로그래밍 인터페이스는 C언어로 정의되어 있으며, 현재는 POSIX 표준으로 정의됨.  
C 라이브러리는 애플리케이션에서 커널로 통하는 관문.  
자바나 파이썬 같은 다른 언어로 프로그램을 작성하더라도, 각 런타임 지원 라이브러리는 결국 C 라이브러리를 불러야 함.  
커널의 서비스가 필요할 때마다 커널 시스템 호출 인터페이스를 통해 사용자 공간과 커널 공간을 전환.

1. **glibc**:  
   표준 GNU C 라이브러리.  
   크기가 크고 최근까지 구성 변경이 용이하지 않지만 POSIX API의 가장 완벽한 구현.  
   LGPL 라이선스.

2. **musl libc**:  
   GNU libc의 대안으로, RAM과 저장 공간의 크기가 제한된 시스템에 좋은 선택.  
   MIT 라이선스.

3. **uClibc-ng**:  
   마이크로컨트롤러 C 라이브러리.  
   uClibc 프로젝트에서 갈라져 나옴.  
   LCPL 라이선스.

4. **eglibc**:  
   glibc를 임베디드용으로 변경한 것.  
   Eglibc에는 glibc가 다루지 않는 아키텍처를 지원하는 구성 옵션이 추가됨.  
   Glibc의 코드 베이스가 다시 glibc 버전 2.20 병합되었으며, 더 이상 유지보수되지 않음.

uClinux를 쓸 때만 uClibc-ng를 쓰는 것을 권장하며, 저장소나 RAM의 크기가 매우 제한되어 있다면 musl libc 선택.

---

# 툴체인 찾기

크로스 개발 툴체인을 구하는 세 가지 방법:

1. 미리 빌드된 툴체인 중에 필요한 사항을 만족하는 것을 찾는 방법.
2. 임베디드 빌드 도구를 통해 생성된 것을 사용하는 방법.
3. 직접 만드는 방법.

---

# C 라이브러리의 요소를 살펴보자

1. **Libc**:  
   Printf, open, close, read, write 등 잘 알려진 POSIX 함수들을 담고 있는 주 C 라이브러리.

2. **Libm**:  
   cos, exp, log 같은 수학 함수들.

3. **Libpthread**:  
   이름이 pthread_로 시작하는 모든 POSIX 스레드 함수들.

4. **Librt**:  
   공유 메모리와 비동기 I/O를 포함하는 POSIX 실시간 확장.

---

# 라이브러리와 링크하기: 정적 링크와 동적 링크

리눅스용으로 작성하는 모든 프로그램은 C 라이브러리인 libc와 링크됨.  
링크하고 싶은 다른 라이브러리는 -l 옵션을 통해 명시적으로 지정해야 함.

### 라이브러리 코드를 링크하는 두 가지 방법

1. **정적 링크**:  
   애플리케이션의 모든 라이브러리 함수와 의존 관계가 라이브러리 아카이브로부터 추출돼 실행 파일에 복사.

2. **동적 링크**:  
   라이브러리 파일과 함수로의 참조가 코드 안에 만들어지지만 실제 링크는 실행 시에 동적으로 이루어짐.

#### 정적 라이브러리
- Busybox와 약간의 스크립트 파일만으로 구성된 작은 시스템을 만든다면 busybox를 정적으로 링크해서 런타임 라이브러리 파일과 링커를 복사할 필요가 없는 편이 더 간단 (애플리케이션이 사용하는 코드만 링크하기 때문에 크기도 더 작아짐).
- 정적 링크는 또한 런타임 라이브러리를 담을 파일 시스템이 준비되기 전에 프로그램을 실행해야 할 때 유용.
- 명령줄에 -static을 추가하면 모든 라이브러리를 정적으로 링크.
- 정적 링크는 보통 lib[name].a 인 라이브러리 아카이브로부터 코드를 복사.

#### 공유 라이브러리
- 실행 시에 링크되는 공유 오브젝트로 사용하는 것으로,
